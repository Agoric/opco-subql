diff --git a/main/helpers/grpc-gateway.js b/main/helpers/grpc-gateway.js
index 054b155311ab9f7ab9d5555b966665c185610e70..dce50b85fa46db5f49b3e0195542ebaa6cf71d28 100644
--- a/main/helpers/grpc-gateway.js
+++ b/main/helpers/grpc-gateway.js
@@ -19,7 +19,7 @@ for (let i = 0; i < 64;)
 
 export function b64Encode(buffer: Uint8Array, start: number, end: number): string {
 	let parts: string[] = null;
-  const chunk = [];
+  const chunk = [] as number[];
   let i = 0, // output index
     j = 0, // goto index
     t;     // temporary
diff --git a/main/helpers/utf8-helper.js b/main/helpers/utf8-helper.js
index 296b0864b9456c17ca8c40d62edee3a74c1a91fd..c8bb9d644a7e49db35d293669bda7bdc5a20ea61 100644
--- a/main/helpers/utf8-helper.js
+++ b/main/helpers/utf8-helper.js
@@ -68,7 +68,7 @@ export function utf8Read(
 ) {
   const len = end - start;
   if (len < 1) return "";
-  const chunk = [];
+  const chunk = [] as number[];
   let parts: string[] = [],
     i = 0, // char offset
     t; // temporary
diff --git a/module/helpers/grpc-gateway.js b/module/helpers/grpc-gateway.js
index e39afd17badfb6870797bac021a37640721d2e01..5b42d3eab0c2dd45205f55a5294e224be4fc274f 100644
--- a/module/helpers/grpc-gateway.js
+++ b/module/helpers/grpc-gateway.js
@@ -16,7 +16,7 @@ for (let i = 0; i < 64;)
 
 export function b64Encode(buffer: Uint8Array, start: number, end: number): string {
 	let parts: string[] = null;
-  const chunk = [];
+  const chunk = [] as number[];
   let i = 0, // output index
     j = 0, // goto index
     t;     // temporary
diff --git a/module/helpers/utf8-helper.js b/module/helpers/utf8-helper.js
index d9ccc6624038cd243d262b28268dc2203a0757a0..15dbf723ffb60cfc6e5bc1315b329a59af192800 100644
--- a/module/helpers/utf8-helper.js
+++ b/module/helpers/utf8-helper.js
@@ -65,7 +65,7 @@ export function utf8Read(
 ) {
   const len = end - start;
   if (len < 1) return "";
-  const chunk = [];
+  const chunk = [] as number[];
   let parts: string[] = [],
     i = 0, // char offset
     t; // temporary
diff --git a/package.json b/package.json
index a4b1104dcd29669071a93981c16e5114642227f1..aa56eb4270d5835c79653ea26d626a5ecd86bc8c 100644
--- a/package.json
+++ b/package.json
@@ -105,5 +105,6 @@
     "parse-package-name": "1.0.0",
     "rimraf": "5.0.0",
     "shelljs": "0.8.5"
-  }
+  },
+  "packageManager": "yarn@1.22.22+sha512.a6b2f7906b721bba3d67d4aff083df04dad64c399707841b7acf00f6b133b7ac24255f2652fa22ae3534329dc6180534e98d17432037ff6fd140556e2bb3137e"
 }
diff --git a/src/helpers/grpc-gateway.ts b/src/helpers/grpc-gateway.ts
index ed92f27b2a6f6ca4ee4def28379c5fbb36d09276..565985e4caa2809b7a1c12811e4c6759f113bc2e 100644
--- a/src/helpers/grpc-gateway.ts
+++ b/src/helpers/grpc-gateway.ts
@@ -16,7 +16,7 @@ for (let i = 0; i < 64;)
 
 export function b64Encode(buffer: Uint8Array, start: number, end: number): string {
 	let parts: string[] = null;
-  const chunk = [];
+  const chunk = [] as number[];
   let i = 0, // output index
     j = 0, // goto index
     t;     // temporary
diff --git a/src/helpers/utf8-helper.ts b/src/helpers/utf8-helper.ts
index bd1e927c7e119ecd85925f4fcde2ab3265e6337f..17f294e041ae5e6c11796f6984e22e7749ea0238 100644
--- a/src/helpers/utf8-helper.ts
+++ b/src/helpers/utf8-helper.ts
@@ -65,7 +65,7 @@ export function utf8Read(
 ) {
   const len = end - start;
   if (len < 1) return "";
-  const chunk = [];
+  const chunk = [] as number[];
   let parts: string[] = [],
     i = 0, // char offset
     t; // temporary
diff --git a/types/helpers/grpc-gateway.d.ts b/types/helpers/grpc-gateway.d.ts
index da444c9036bed159cb8e6dff17d5e71f1d64396d..defe5f3e451cd58a096889807d14983697750f09 100644
--- a/types/helpers/grpc-gateway.d.ts
+++ b/types/helpers/grpc-gateway.d.ts
@@ -1 +1 @@
-export declare const grpcGateway = "\n\n/**\n * base64 encoder and decoder\n * Copied and adapted from https://github.com/protobufjs/protobuf.js/blob/master/lib/base64/index.js\n */\n// Base64 encoding table\nconst b64 = new Array(64);\n\n// Base64 decoding table\nconst s64 = new Array(123);\n\n// 65..90, 97..122, 48..57, 43, 47\nfor (let i = 0; i < 64;)\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\n\nexport function b64Encode(buffer: Uint8Array, start: number, end: number): string {\n\tlet parts: string[] = null;\n  const chunk = [];\n  let i = 0, // output index\n    j = 0, // goto index\n    t;     // temporary\n  while (start < end) {\n    const b = buffer[start++];\n    switch (j) {\n      case 0:\n        chunk[i++] = b64[b >> 2];\n        t = (b & 3) << 4;\n        j = 1;\n        break;\n      case 1:\n        chunk[i++] = b64[t | b >> 4];\n        t = (b & 15) << 2;\n        j = 2;\n        break;\n      case 2:\n        chunk[i++] = b64[t | b >> 6];\n        chunk[i++] = b64[b & 63];\n        j = 0;\n        break;\n    }\n    if (i > 8191) {\n      (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n      i = 0;\n    }\n  }\n  if (j) {\n    chunk[i++] = b64[t];\n    chunk[i++] = 61;\n    if (j === 1)\n      chunk[i++] = 61;\n  }\n  if (parts) {\n    if (i)\n      parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\n    return parts.join(\"\");\n  }\n  return String.fromCharCode.apply(String, chunk.slice(0, i));\n}\n\nconst invalidEncoding = \"invalid encoding\";\n\nexport function b64Decode(s: string): Uint8Array {\n\tconst buffer = [];\n\tlet offset = 0;\n  let j = 0, // goto index\n      t;     // temporary\n  for (let i = 0; i < s.length;) {\n    let c = s.charCodeAt(i++);\n    if (c === 61 && j > 1)\n        break;\n    if ((c = s64[c]) === undefined)\n        throw Error(invalidEncoding);\n    switch (j) {\n      case 0:\n        t = c;\n        j = 1;\n        break;\n      case 1:\n        buffer[offset++] = t << 2 | (c & 48) >> 4;\n        t = c;\n        j = 2;\n        break;\n      case 2:\n        buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\n        t = c;\n        j = 3;\n        break;\n      case 3:\n        buffer[offset++] = (t & 3) << 6 | c;\n        j = 0;\n        break;\n    }\n  }\n  if (j === 1)\n      throw Error(invalidEncoding);\n  return new Uint8Array(buffer);\n}\n\nfunction b64Test(s: string): boolean {\n\treturn /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(s);\n}\n\nexport interface InitReq extends RequestInit {\n  pathPrefix?: string\n}\n\nexport function replacer(key: any, value: any): any {\n  if(value && value.constructor === Uint8Array) {\n    return b64Encode(value, 0, value.length);\n  }\n\n  return value;\n}\n\nexport function fetchReq<I, O>(path: string, init?: InitReq): Promise<O> {\n  const {pathPrefix, ...req} = init || {}\n\n  const url = pathPrefix ? `${pathPrefix}${path}` : path\n\n  return fetch(url, req).then(r => r.json().then((body: O) => {\n    if (!r.ok) { throw body; }\n    return body;\n  })) as Promise<O>\n}\n\n// NotifyStreamEntityArrival is a callback that will be called on streaming entity arrival\nexport type NotifyStreamEntityArrival<T> = (resp: T) => void\n\n/**\n * fetchStreamingRequest is able to handle grpc-gateway server side streaming call\n * it takes NotifyStreamEntityArrival that lets users respond to entity arrival during the call\n * all entities will be returned as an array after the call finishes.\n **/\nexport async function fetchStreamingRequest<S, R>(path: string, callback?: NotifyStreamEntityArrival<R>, init?: InitReq) {\n  const {pathPrefix, ...req} = init || {}\n  const url = pathPrefix ? `${pathPrefix}${path}` : path\n  const result = await fetch(url, req)\n  // needs to use the .ok to check the status of HTTP status code\n  // http other than 200 will not throw an error, instead the .ok will become false.\n  // see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#\n  if (!result.ok) {\n    const resp = await result.json()\n    const errMsg = resp.error && resp.error.message ? resp.error.message : \"\"\n    throw new Error(errMsg)\n  }\n\n  if (!result.body) {\n    throw new Error(\"response doesnt have a body\")\n  }\n\n  await result.body\n    .pipeThrough(new TextDecoderStream())\n    .pipeThrough<R>(getNewLineDelimitedJSONDecodingStream<R>())\n    .pipeTo(getNotifyEntityArrivalSink((e: R) => {\n      if (callback) {\n        callback(e)\n      }\n    }))\n\n  // wait for the streaming to finish and return the success respond\n  return\n}\n\n/**\n * JSONStringStreamController represents the transform controller that's able to transform the incoming\n * new line delimited json content stream into entities and able to push the entity to the down stream\n */\ninterface JSONStringStreamController<T> extends TransformStreamDefaultController {\n  buf?: string\n  pos?: number\n  enqueue: (s: T) => void\n}\n\n/**\n * getNewLineDelimitedJSONDecodingStream returns a TransformStream that's able to handle new line delimited json stream content into parsed entities\n */\nfunction getNewLineDelimitedJSONDecodingStream<T>(): TransformStream<string, T> {\n  return new TransformStream({\n    start(controller: JSONStringStreamController<T>) {\n      controller.buf = ''\n      controller.pos = 0\n    },\n\n    transform(chunk: string, controller: JSONStringStreamController<T>) {\n      if (controller.buf === undefined) {\n        controller.buf = ''\n      }\n      if (controller.pos === undefined) {\n        controller.pos = 0\n      }\n      controller.buf += chunk\n      while (controller.pos < controller.buf.length) {\n        if (controller.buf[controller.pos] === '\\n') {\n          const line = controller.buf.substring(0, controller.pos)\n          const response = JSON.parse(line)\n          controller.enqueue(response.result)\n          controller.buf = controller.buf.substring(controller.pos + 1)\n          controller.pos = 0\n        } else {\n          ++controller.pos\n        }\n      }\n    }\n  })\n\n}\n\n/**\n * getNotifyEntityArrivalSink takes the NotifyStreamEntityArrival callback and return\n * a sink that will call the callback on entity arrival\n * @param notifyCallback\n */\nfunction getNotifyEntityArrivalSink<T>(notifyCallback: NotifyStreamEntityArrival<T>) {\n  return new WritableStream<T>({\n    write(entity: T) {\n      notifyCallback(entity)\n    }\n  })\n}\n\ntype Primitive = string | boolean | number;\ntype RequestPayload = Record<string, unknown>;\ntype FlattenedRequestPayload = Record<string, Primitive | Array<Primitive>>;\n\n/**\n * Checks if given value is a plain object\n * Logic copied and adapted from below source: \n * https://github.com/char0n/ramda-adjunct/blob/master/src/isPlainObj.js\n * @param  {unknown} value\n * @return {boolean}\n */\nfunction isPlainObject(value: unknown): boolean {\n  const isObject =\n    Object.prototype.toString.call(value).slice(8, -1) === \"Object\";\n  const isObjLike = value !== null && isObject;\n\n  if (!isObjLike || !isObject) {\n    return false;\n  }\n\n  const proto = Object.getPrototypeOf(value);\n\n  const hasObjectConstructor =\n    typeof proto === \"object\" &&\n    proto.constructor === Object.prototype.constructor;\n\n  return hasObjectConstructor;\n}\n\n/**\n * Checks if given value is of a primitive type\n * @param  {unknown} value\n * @return {boolean}\n */\nfunction isPrimitive(value: unknown): boolean {\n  return [\"string\", \"number\", \"boolean\"].some(t => typeof value === t);\n}\n\n/**\n * Checks if given primitive is zero-value\n * @param  {Primitive} value\n * @return {boolean}\n */\nfunction isZeroValuePrimitive(value: Primitive): boolean {\n  return value === false || value === 0 || value === \"\";\n}\n\n/**\n * Flattens a deeply nested request payload and returns an object\n * with only primitive values and non-empty array of primitive values\n * as per https://github.com/googleapis/googleapis/blob/master/google/api/http.proto\n * @param  {RequestPayload} requestPayload\n * @param  {String} path\n * @return {FlattenedRequestPayload>}\n */\nfunction flattenRequestPayload<T extends RequestPayload>(\n  requestPayload: T,\n  path: string = \"\"\n): FlattenedRequestPayload {\n  return Object.keys(requestPayload).reduce(\n    (acc: T, key: string): T => {\n      const value = requestPayload[key];\n      const newPath = path ? [path, key].join(\".\") : key;\n\n      const isNonEmptyPrimitiveArray =\n        Array.isArray(value) &&\n        value.every(v => isPrimitive(v)) &&\n        value.length > 0;\n\n      const isNonZeroValuePrimitive =\n        isPrimitive(value) && !isZeroValuePrimitive(value as Primitive);\n\n      let objectToMerge = {};\n\n      if (isPlainObject(value)) {\n        objectToMerge = flattenRequestPayload(value as RequestPayload, newPath);\n      } else if (value && value.constructor === Uint8Array) {\n        objectToMerge = {\n          [newPath]: b64Encode(value, 0, value.length),\n        };\n      } else if (isNonZeroValuePrimitive || isNonEmptyPrimitiveArray) {\n        objectToMerge = { [newPath]: value };\n      }\n\n      return { ...acc, ...objectToMerge };\n    },\n    {} as T\n  ) as FlattenedRequestPayload;\n}\n\n/**\n * Renders a deeply nested request payload into a string of URL search\n * parameters by first flattening the request payload and then removing keys\n * which are already present in the URL path.\n * @param  {RequestPayload} requestPayload\n * @param  {string[]} urlPathParams\n * @return {string}\n */\nexport function renderURLSearchParams<T extends RequestPayload>(\n  requestPayload: T,\n  urlPathParams: string[] = []\n): string {\n  const flattenedRequestPayload = flattenRequestPayload(requestPayload);\n\n  const urlSearchParams = Object.keys(flattenedRequestPayload).reduce(\n    (acc: string[][], key: string): string[][] => {\n      // key should not be present in the url path as a parameter\n      const value = flattenedRequestPayload[key];\n      if (urlPathParams.find(f => f === key)) {\n        return acc;\n      }\n      return Array.isArray(value)\n        ? [...acc, ...value.map(m => [key, m.toString()])]\n        : (acc = [...acc, [key, value.toString()]]);\n    },\n    [] as string[][]\n  );\n\n  // react-native's URLSearchParams doesn't like working with array of arrays\n  return urlSearchParams\n    .map((x) => new URLSearchParams({ [x[0]]: x[1] }).toString())\n    .join(\"&\");\n}\n";
+export declare const grpcGateway = "\n\n/**\n * base64 encoder and decoder\n * Copied and adapted from https://github.com/protobufjs/protobuf.js/blob/master/lib/base64/index.js\n */\n// Base64 encoding table\nconst b64 = new Array(64);\n\n// Base64 decoding table\nconst s64 = new Array(123);\n\n// 65..90, 97..122, 48..57, 43, 47\nfor (let i = 0; i < 64;)\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\n\nexport function b64Encode(buffer: Uint8Array, start: number, end: number): string {\n\tlet parts: string[] = null;\n  const chunk = [] as number[];\n  let i = 0, // output index\n    j = 0, // goto index\n    t;     // temporary\n  while (start < end) {\n    const b = buffer[start++];\n    switch (j) {\n      case 0:\n        chunk[i++] = b64[b >> 2];\n        t = (b & 3) << 4;\n        j = 1;\n        break;\n      case 1:\n        chunk[i++] = b64[t | b >> 4];\n        t = (b & 15) << 2;\n        j = 2;\n        break;\n      case 2:\n        chunk[i++] = b64[t | b >> 6];\n        chunk[i++] = b64[b & 63];\n        j = 0;\n        break;\n    }\n    if (i > 8191) {\n      (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n      i = 0;\n    }\n  }\n  if (j) {\n    chunk[i++] = b64[t];\n    chunk[i++] = 61;\n    if (j === 1)\n      chunk[i++] = 61;\n  }\n  if (parts) {\n    if (i)\n      parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\n    return parts.join(\"\");\n  }\n  return String.fromCharCode.apply(String, chunk.slice(0, i));\n}\n\nconst invalidEncoding = \"invalid encoding\";\n\nexport function b64Decode(s: string): Uint8Array {\n\tconst buffer = [];\n\tlet offset = 0;\n  let j = 0, // goto index\n      t;     // temporary\n  for (let i = 0; i < s.length;) {\n    let c = s.charCodeAt(i++);\n    if (c === 61 && j > 1)\n        break;\n    if ((c = s64[c]) === undefined)\n        throw Error(invalidEncoding);\n    switch (j) {\n      case 0:\n        t = c;\n        j = 1;\n        break;\n      case 1:\n        buffer[offset++] = t << 2 | (c & 48) >> 4;\n        t = c;\n        j = 2;\n        break;\n      case 2:\n        buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\n        t = c;\n        j = 3;\n        break;\n      case 3:\n        buffer[offset++] = (t & 3) << 6 | c;\n        j = 0;\n        break;\n    }\n  }\n  if (j === 1)\n      throw Error(invalidEncoding);\n  return new Uint8Array(buffer);\n}\n\nfunction b64Test(s: string): boolean {\n\treturn /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(s);\n}\n\nexport interface InitReq extends RequestInit {\n  pathPrefix?: string\n}\n\nexport function replacer(key: any, value: any): any {\n  if(value && value.constructor === Uint8Array) {\n    return b64Encode(value, 0, value.length);\n  }\n\n  return value;\n}\n\nexport function fetchReq<I, O>(path: string, init?: InitReq): Promise<O> {\n  const {pathPrefix, ...req} = init || {}\n\n  const url = pathPrefix ? `${pathPrefix}${path}` : path\n\n  return fetch(url, req).then(r => r.json().then((body: O) => {\n    if (!r.ok) { throw body; }\n    return body;\n  })) as Promise<O>\n}\n\n// NotifyStreamEntityArrival is a callback that will be called on streaming entity arrival\nexport type NotifyStreamEntityArrival<T> = (resp: T) => void\n\n/**\n * fetchStreamingRequest is able to handle grpc-gateway server side streaming call\n * it takes NotifyStreamEntityArrival that lets users respond to entity arrival during the call\n * all entities will be returned as an array after the call finishes.\n **/\nexport async function fetchStreamingRequest<S, R>(path: string, callback?: NotifyStreamEntityArrival<R>, init?: InitReq) {\n  const {pathPrefix, ...req} = init || {}\n  const url = pathPrefix ? `${pathPrefix}${path}` : path\n  const result = await fetch(url, req)\n  // needs to use the .ok to check the status of HTTP status code\n  // http other than 200 will not throw an error, instead the .ok will become false.\n  // see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#\n  if (!result.ok) {\n    const resp = await result.json()\n    const errMsg = resp.error && resp.error.message ? resp.error.message : \"\"\n    throw new Error(errMsg)\n  }\n\n  if (!result.body) {\n    throw new Error(\"response doesnt have a body\")\n  }\n\n  await result.body\n    .pipeThrough(new TextDecoderStream())\n    .pipeThrough<R>(getNewLineDelimitedJSONDecodingStream<R>())\n    .pipeTo(getNotifyEntityArrivalSink((e: R) => {\n      if (callback) {\n        callback(e)\n      }\n    }))\n\n  // wait for the streaming to finish and return the success respond\n  return\n}\n\n/**\n * JSONStringStreamController represents the transform controller that's able to transform the incoming\n * new line delimited json content stream into entities and able to push the entity to the down stream\n */\ninterface JSONStringStreamController<T> extends TransformStreamDefaultController {\n  buf?: string\n  pos?: number\n  enqueue: (s: T) => void\n}\n\n/**\n * getNewLineDelimitedJSONDecodingStream returns a TransformStream that's able to handle new line delimited json stream content into parsed entities\n */\nfunction getNewLineDelimitedJSONDecodingStream<T>(): TransformStream<string, T> {\n  return new TransformStream({\n    start(controller: JSONStringStreamController<T>) {\n      controller.buf = ''\n      controller.pos = 0\n    },\n\n    transform(chunk: string, controller: JSONStringStreamController<T>) {\n      if (controller.buf === undefined) {\n        controller.buf = ''\n      }\n      if (controller.pos === undefined) {\n        controller.pos = 0\n      }\n      controller.buf += chunk\n      while (controller.pos < controller.buf.length) {\n        if (controller.buf[controller.pos] === '\\n') {\n          const line = controller.buf.substring(0, controller.pos)\n          const response = JSON.parse(line)\n          controller.enqueue(response.result)\n          controller.buf = controller.buf.substring(controller.pos + 1)\n          controller.pos = 0\n        } else {\n          ++controller.pos\n        }\n      }\n    }\n  })\n\n}\n\n/**\n * getNotifyEntityArrivalSink takes the NotifyStreamEntityArrival callback and return\n * a sink that will call the callback on entity arrival\n * @param notifyCallback\n */\nfunction getNotifyEntityArrivalSink<T>(notifyCallback: NotifyStreamEntityArrival<T>) {\n  return new WritableStream<T>({\n    write(entity: T) {\n      notifyCallback(entity)\n    }\n  })\n}\n\ntype Primitive = string | boolean | number;\ntype RequestPayload = Record<string, unknown>;\ntype FlattenedRequestPayload = Record<string, Primitive | Array<Primitive>>;\n\n/**\n * Checks if given value is a plain object\n * Logic copied and adapted from below source: \n * https://github.com/char0n/ramda-adjunct/blob/master/src/isPlainObj.js\n * @param  {unknown} value\n * @return {boolean}\n */\nfunction isPlainObject(value: unknown): boolean {\n  const isObject =\n    Object.prototype.toString.call(value).slice(8, -1) === \"Object\";\n  const isObjLike = value !== null && isObject;\n\n  if (!isObjLike || !isObject) {\n    return false;\n  }\n\n  const proto = Object.getPrototypeOf(value);\n\n  const hasObjectConstructor =\n    typeof proto === \"object\" &&\n    proto.constructor === Object.prototype.constructor;\n\n  return hasObjectConstructor;\n}\n\n/**\n * Checks if given value is of a primitive type\n * @param  {unknown} value\n * @return {boolean}\n */\nfunction isPrimitive(value: unknown): boolean {\n  return [\"string\", \"number\", \"boolean\"].some(t => typeof value === t);\n}\n\n/**\n * Checks if given primitive is zero-value\n * @param  {Primitive} value\n * @return {boolean}\n */\nfunction isZeroValuePrimitive(value: Primitive): boolean {\n  return value === false || value === 0 || value === \"\";\n}\n\n/**\n * Flattens a deeply nested request payload and returns an object\n * with only primitive values and non-empty array of primitive values\n * as per https://github.com/googleapis/googleapis/blob/master/google/api/http.proto\n * @param  {RequestPayload} requestPayload\n * @param  {String} path\n * @return {FlattenedRequestPayload>}\n */\nfunction flattenRequestPayload<T extends RequestPayload>(\n  requestPayload: T,\n  path: string = \"\"\n): FlattenedRequestPayload {\n  return Object.keys(requestPayload).reduce(\n    (acc: T, key: string): T => {\n      const value = requestPayload[key];\n      const newPath = path ? [path, key].join(\".\") : key;\n\n      const isNonEmptyPrimitiveArray =\n        Array.isArray(value) &&\n        value.every(v => isPrimitive(v)) &&\n        value.length > 0;\n\n      const isNonZeroValuePrimitive =\n        isPrimitive(value) && !isZeroValuePrimitive(value as Primitive);\n\n      let objectToMerge = {};\n\n      if (isPlainObject(value)) {\n        objectToMerge = flattenRequestPayload(value as RequestPayload, newPath);\n      } else if (value && value.constructor === Uint8Array) {\n        objectToMerge = {\n          [newPath]: b64Encode(value, 0, value.length),\n        };\n      } else if (isNonZeroValuePrimitive || isNonEmptyPrimitiveArray) {\n        objectToMerge = { [newPath]: value };\n      }\n\n      return { ...acc, ...objectToMerge };\n    },\n    {} as T\n  ) as FlattenedRequestPayload;\n}\n\n/**\n * Renders a deeply nested request payload into a string of URL search\n * parameters by first flattening the request payload and then removing keys\n * which are already present in the URL path.\n * @param  {RequestPayload} requestPayload\n * @param  {string[]} urlPathParams\n * @return {string}\n */\nexport function renderURLSearchParams<T extends RequestPayload>(\n  requestPayload: T,\n  urlPathParams: string[] = []\n): string {\n  const flattenedRequestPayload = flattenRequestPayload(requestPayload);\n\n  const urlSearchParams = Object.keys(flattenedRequestPayload).reduce(\n    (acc: string[][], key: string): string[][] => {\n      // key should not be present in the url path as a parameter\n      const value = flattenedRequestPayload[key];\n      if (urlPathParams.find(f => f === key)) {\n        return acc;\n      }\n      return Array.isArray(value)\n        ? [...acc, ...value.map(m => [key, m.toString()])]\n        : (acc = [...acc, [key, value.toString()]]);\n    },\n    [] as string[][]\n  );\n\n  // react-native's URLSearchParams doesn't like working with array of arrays\n  return urlSearchParams\n    .map((x) => new URLSearchParams({ [x[0]]: x[1] }).toString())\n    .join(\"&\");\n}\n";
diff --git a/types/helpers/utf8-helper.d.ts b/types/helpers/utf8-helper.d.ts
index 2fb89eef032bfd4b0ef862b3981198acf54d4adc..222f4b36d9d3f0230ded2977c67118fdaf3f5ebd 100644
--- a/types/helpers/utf8-helper.d.ts
+++ b/types/helpers/utf8-helper.d.ts
@@ -1 +1 @@
-export declare const utf8 = "\n// Copyright (c) 2016, Daniel Wirtz  All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n\n// * Redistributions of source code must retain the above copyright\n//   notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the\n//   documentation and/or other materials provided with the distribution.\n// * Neither the name of its author, nor the names of its contributors\n//   may be used to endorse or promote products derived from this software\n//   without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\"use strict\";\n\n/**\n * Calculates the UTF8 byte length of a string.\n * @param {string} string String\n * @returns {number} Byte length\n */\nexport function utf8Length(str: string) {\n  let len = 0,\n    c = 0;\n  for (let i = 0; i < str.length; ++i) {\n    c = str.charCodeAt(i);\n    if (c < 128) len += 1;\n    else if (c < 2048) len += 2;\n    else if (\n      (c & 0xfc00) === 0xd800 &&\n      (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00\n    ) {\n      ++i;\n      len += 4;\n    } else len += 3;\n  }\n  return len;\n}\n\n/**\n * Reads UTF8 bytes as a string.\n * @param {Uint8Array} buffer Source buffer\n * @param {number} start Source start\n * @param {number} end Source end\n * @returns {string} String read\n */\nexport function utf8Read(\n  buffer: ArrayLike<number>,\n  start: number,\n  end: number\n) {\n  const len = end - start;\n  if (len < 1) return \"\";\n  const chunk = [];\n  let parts: string[] = [],\n    i = 0, // char offset\n    t; // temporary\n  while (start < end) {\n    t = buffer[start++];\n    if (t < 128) chunk[i++] = t;\n    else if (t > 191 && t < 224)\n      chunk[i++] = ((t & 31) << 6) | (buffer[start++] & 63);\n    else if (t > 239 && t < 365) {\n      t =\n        (((t & 7) << 18) |\n          ((buffer[start++] & 63) << 12) |\n          ((buffer[start++] & 63) << 6) |\n          (buffer[start++] & 63)) -\n        0x10000;\n      chunk[i++] = 0xd800 + (t >> 10);\n      chunk[i++] = 0xdc00 + (t & 1023);\n    } else\n      chunk[i++] =\n        ((t & 15) << 12) |\n        ((buffer[start++] & 63) << 6) |\n        (buffer[start++] & 63);\n    if (i > 8191) {\n      (parts || (parts = [])).push(String.fromCharCode(...chunk));\n      i = 0;\n    }\n  }\n  if (parts) {\n    if (i) parts.push(String.fromCharCode(...chunk.slice(0, i)));\n    return parts.join(\"\");\n  }\n  return String.fromCharCode(...chunk.slice(0, i));\n}\n\n/**\n * Writes a string as UTF8 bytes.\n * @param {string} string Source string\n * @param {Uint8Array} buffer Destination buffer\n * @param {number} offset Destination offset\n * @returns {number} Bytes written\n */\nexport function utf8Write(\n  str: string,\n  buffer: Uint8Array | Array<number>,\n  offset: number\n) {\n  const start = offset;\n  let c1, // character 1\n    c2; // character 2\n  for (let i = 0; i < str.length; ++i) {\n    c1 = str.charCodeAt(i);\n    if (c1 < 128) {\n      buffer[offset++] = c1;\n    } else if (c1 < 2048) {\n      buffer[offset++] = (c1 >> 6) | 192;\n      buffer[offset++] = (c1 & 63) | 128;\n    } else if (\n      (c1 & 0xfc00) === 0xd800 &&\n      ((c2 = str.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n    ) {\n      c1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);\n      ++i;\n      buffer[offset++] = (c1 >> 18) | 240;\n      buffer[offset++] = ((c1 >> 12) & 63) | 128;\n      buffer[offset++] = ((c1 >> 6) & 63) | 128;\n      buffer[offset++] = (c1 & 63) | 128;\n    } else {\n      buffer[offset++] = (c1 >> 12) | 224;\n      buffer[offset++] = ((c1 >> 6) & 63) | 128;\n      buffer[offset++] = (c1 & 63) | 128;\n    }\n  }\n  return offset - start;\n}\n";
+export declare const utf8 = "\n// Copyright (c) 2016, Daniel Wirtz  All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n\n// * Redistributions of source code must retain the above copyright\n//   notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the\n//   documentation and/or other materials provided with the distribution.\n// * Neither the name of its author, nor the names of its contributors\n//   may be used to endorse or promote products derived from this software\n//   without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\"use strict\";\n\n/**\n * Calculates the UTF8 byte length of a string.\n * @param {string} string String\n * @returns {number} Byte length\n */\nexport function utf8Length(str: string) {\n  let len = 0,\n    c = 0;\n  for (let i = 0; i < str.length; ++i) {\n    c = str.charCodeAt(i);\n    if (c < 128) len += 1;\n    else if (c < 2048) len += 2;\n    else if (\n      (c & 0xfc00) === 0xd800 &&\n      (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00\n    ) {\n      ++i;\n      len += 4;\n    } else len += 3;\n  }\n  return len;\n}\n\n/**\n * Reads UTF8 bytes as a string.\n * @param {Uint8Array} buffer Source buffer\n * @param {number} start Source start\n * @param {number} end Source end\n * @returns {string} String read\n */\nexport function utf8Read(\n  buffer: ArrayLike<number>,\n  start: number,\n  end: number\n) {\n  const len = end - start;\n  if (len < 1) return \"\";\n  const chunk = [] as number[];\n  let parts: string[] = [],\n    i = 0, // char offset\n    t; // temporary\n  while (start < end) {\n    t = buffer[start++];\n    if (t < 128) chunk[i++] = t;\n    else if (t > 191 && t < 224)\n      chunk[i++] = ((t & 31) << 6) | (buffer[start++] & 63);\n    else if (t > 239 && t < 365) {\n      t =\n        (((t & 7) << 18) |\n          ((buffer[start++] & 63) << 12) |\n          ((buffer[start++] & 63) << 6) |\n          (buffer[start++] & 63)) -\n        0x10000;\n      chunk[i++] = 0xd800 + (t >> 10);\n      chunk[i++] = 0xdc00 + (t & 1023);\n    } else\n      chunk[i++] =\n        ((t & 15) << 12) |\n        ((buffer[start++] & 63) << 6) |\n        (buffer[start++] & 63);\n    if (i > 8191) {\n      (parts || (parts = [])).push(String.fromCharCode(...chunk));\n      i = 0;\n    }\n  }\n  if (parts) {\n    if (i) parts.push(String.fromCharCode(...chunk.slice(0, i)));\n    return parts.join(\"\");\n  }\n  return String.fromCharCode(...chunk.slice(0, i));\n}\n\n/**\n * Writes a string as UTF8 bytes.\n * @param {string} string Source string\n * @param {Uint8Array} buffer Destination buffer\n * @param {number} offset Destination offset\n * @returns {number} Bytes written\n */\nexport function utf8Write(\n  str: string,\n  buffer: Uint8Array | Array<number>,\n  offset: number\n) {\n  const start = offset;\n  let c1, // character 1\n    c2; // character 2\n  for (let i = 0; i < str.length; ++i) {\n    c1 = str.charCodeAt(i);\n    if (c1 < 128) {\n      buffer[offset++] = c1;\n    } else if (c1 < 2048) {\n      buffer[offset++] = (c1 >> 6) | 192;\n      buffer[offset++] = (c1 & 63) | 128;\n    } else if (\n      (c1 & 0xfc00) === 0xd800 &&\n      ((c2 = str.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n    ) {\n      c1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);\n      ++i;\n      buffer[offset++] = (c1 >> 18) | 240;\n      buffer[offset++] = ((c1 >> 12) & 63) | 128;\n      buffer[offset++] = ((c1 >> 6) & 63) | 128;\n      buffer[offset++] = (c1 & 63) | 128;\n    } else {\n      buffer[offset++] = (c1 >> 12) | 224;\n      buffer[offset++] = ((c1 >> 6) & 63) | 128;\n      buffer[offset++] = (c1 & 63) | 128;\n    }\n  }\n  return offset - start;\n}\n";
